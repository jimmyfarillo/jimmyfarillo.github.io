<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.6.1 -->
<title>Async/Await in ES7 (ES2016) | Jimmy Farillo</title>
<meta name="generator" content="Jekyll v3.8.5" />
<meta property="og:title" content="Async/Await in ES7 (ES2016)" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="I’ve recently been learning a bit about Koa , which uses ES6 (ES2015) generator functions in its design and allows us to treat our asynchronous operations differently than using callbacks or promises." />
<meta property="og:description" content="I’ve recently been learning a bit about Koa , which uses ES6 (ES2015) generator functions in its design and allows us to treat our asynchronous operations differently than using callbacks or promises." />
<link rel="canonical" href="/2015/08/27/async-await-in-es7-es2016.html" />
<meta property="og:url" content="/2015/08/27/async-await-in-es7-es2016.html" />
<meta property="og:site_name" content="Jimmy Farillo" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2015-08-27T00:00:00-04:00" />
<script type="application/ld+json">
{"url":"/2015/08/27/async-await-in-es7-es2016.html","headline":"Async/Await in ES7 (ES2016)","dateModified":"2015-08-27T00:00:00-04:00","datePublished":"2015-08-27T00:00:00-04:00","description":"I’ve recently been learning a bit about Koa , which uses ES6 (ES2015) generator functions in its design and allows us to treat our asynchronous operations differently than using callbacks or promises.","mainEntityOfPage":{"@type":"WebPage","@id":"/2015/08/27/async-await-in-es7-es2016.html"},"@type":"BlogPosting","@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/assets/main.css"><link type="application/atom+xml" rel="alternate" href="/feed.xml" title="Jimmy Farillo" /></head>
<body><header class="site-header" role="banner">

  <div class="wrapper"><a class="site-title" rel="author" href="/">Jimmy Farillo</a><nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger"><a class="page-link" href="/about/">About</a></div>
      </nav></div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title p-name" itemprop="name headline">Async/Await in ES7 (ES2016)</h1>
    <p class="post-meta">
      <time class="dt-published" datetime="2015-08-27T00:00:00-04:00" itemprop="datePublished">Aug 27, 2015
      </time></p>
  </header>

  <div class="post-content e-content" itemprop="articleBody">
    <p>I’ve recently been
<a href="/2015/08/13/everything-you-want-to-know-about-koa.html">learning a bit about Koa</a>
, which uses ES6 (ES2015) generator functions in its design and allows us to
treat our asynchronous operations differently than using callbacks or promises.</p>

<p>After <a href="http://www.nycnode.com/videos/jimmy-farrell-downstream-and-upstream-request-flow-with-the-koa-web-framework">I presented about Koa at the NYC Node.js
meetup</a>,
fellow presenter <a href="https://twitter.com/eddiezane">Eddie Zaneski</a> showed me
something even more awesome than generators: <code class="language-plaintext highlighter-rouge">async</code> / <code class="language-plaintext highlighter-rouge">await</code>.</p>

<p>Here’s an example of <code class="language-plaintext highlighter-rouge">async</code> / <code class="language-plaintext highlighter-rouge">await</code> in action:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>async function doSomeStuff() {
  try {
    let results1 = await returnsAPromise();
    let results2 = await alsoReturnsAPromise();
    return { results1, results2 };
  } catch (err) {
    throw new Error(err);
  }
}
</code></pre></div></div>

<p>Our function is defined as an <code class="language-plaintext highlighter-rouge">async function</code>, which gives us access to a new
keyword, <code class="language-plaintext highlighter-rouge">await</code>. This keyword does exactly what it says; it waits for an
asynchronous operation to complete (either resolve or reject) before continuing
on with the rest of the function’s code.</p>

<p>The asynchronous operation that is being waited for must return a promise. If
that promise resolves successfully, then the resolved value is returned from
<code class="language-plaintext highlighter-rouge">await</code>. It the promise is rejected, the execution of the code moves in the
<code class="language-plaintext highlighter-rouge">catch</code> block.</p>

<p>This code structure may look familiar if you read my post on Koa. That’s
because Koa and <code class="language-plaintext highlighter-rouge">async</code> / <code class="language-plaintext highlighter-rouge">await</code> are both built using coroutines. However, the
internals of how each implements coroutines is quite different. In short, Koa
uses generator functions and a library called co, while <code class="language-plaintext highlighter-rouge">async</code> / <code class="language-plaintext highlighter-rouge">await</code> uses
a library called node-fibers. More on this here.</p>

<p>Back to the code.</p>

<p>Dealing with asynchronicity using <code class="language-plaintext highlighter-rouge">async</code> / <code class="language-plaintext highlighter-rouge">await</code> looks a lot like
synchronous code, and that’s the whole point. No need for messy callbacks or
promises to handle control flow.</p>

<p>And though the code may look synchronous, <code class="language-plaintext highlighter-rouge">async</code> / <code class="language-plaintext highlighter-rouge">await</code> does not block the
JavaScript event loop. This means that other operations can be performed while
our function is awaiting the promise to be resolved/rejected.</p>

<p>Concurrency with <code class="language-plaintext highlighter-rouge">async</code> / <code class="language-plaintext highlighter-rouge">await</code> is also quite simple by wrapping the
asynchronous operations that are to be performed in parallel in a
<code class="language-plaintext highlighter-rouge">Promise.all</code>. Like so:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>async function manyThings() {
  try {
    let promises = [thing1(), thing2(), thing3()];
    await Promise.all(promises);
  } catch (err) {
    throw new Error(err);
  }
}
</code></pre></div></div>

<p>I’ve also seen that <code class="language-plaintext highlighter-rouge">await*</code> is proposed syntactic sugar for <code class="language-plaintext highlighter-rouge">Promise.all</code>.
Meaning that we could achieve the same thing as above by doing:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>async function manyThings() {
  try {
    let promises = [thing1(), thing2(), thing3()];
    await* promises;
  } catch (err) {
    throw new Error(err);
  }
}
</code></pre></div></div>

<p>This code is slightly nicer, since we don’t have to directly interact with the
Promise API. But, alas, we may or may not get this syntax when the ES7 specs
are finalized. Either way, I’m definitely looking forward to <code class="language-plaintext highlighter-rouge">async</code> / <code class="language-plaintext highlighter-rouge">await</code>!</p>

  </div><a class="u-url" href="/2015/08/27/async-await-in-es7-es2016.html" hidden></a>
</article>

      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/"></data>

  <div class="wrapper">

    <h2 class="footer-heading">Jimmy Farillo</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list"><li><a class="u-email" href="mailto:jimmy@farillo.co">jimmy@farillo.co</a></li></ul>
      </div>

      <div class="footer-col footer-col-2"><ul class="social-media-list"><li><a href="https://github.com/jimmyfarillo"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#github"></use></svg> <span class="username">jimmyfarillo</span></a></li><li><a href="https://www.linkedin.com/in/jimmyfarillo"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#linkedin"></use></svg> <span class="username">jimmyfarillo</span></a></li></ul>
</div>

      <div class="footer-col footer-col-3">
        <p>NYC software engineer</p>
      </div>
    </div>

  </div>

</footer>
</body>

</html>
