<!DOCTYPE html>
<html lang="en">

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  
  
  <title>Async/Await in ES7 (ES2016)</title>
  <meta name="description" content="I’ve recently been learning a bit about Koa , which uses ES6 (ES2015) generator functions in its design and allows us to treat our asynchronous operations differently than using callbacks or promises.">
  

  <link rel="stylesheet" href="/assets/main.css">
  <link rel="canonical" href="https://heyjimmy.co/2015/08/27/async-await-in-es7-es2016/">
  
  
  <link rel="alternate" type="application/rss+xml" title="Jimmy Farillo" href="https://heyjimmy.co/feed.xml">

  

  
  <meta property="og:title" content="Async/Await in ES7 (ES2016)">
  <meta property="og:site_name" content="Jimmy Farillo">
  <meta property="og:url" content="https://heyjimmy.co/2015/08/27/async-await-in-es7-es2016/">
  <meta property="og:description" content="I’ve recently been learning a bit about Koa , which uses ES6 (ES2015) generator functions in its design and allows us to treat our asynchronous operations differently than using callbacks or promises.">
  
  
  <meta name="twitter:card" content="summary">
  
  <meta name="twitter:title" content="Async/Await in ES7 (ES2016)">
  <meta name="twitter:description" content="I’ve recently been learning a bit about Koa , which uses ES6 (ES2015) generator functions in its design and allows us to treat our asynchronous operations differently than using callbacks or promises.">
  
  

  <link rel="dns-prefetch" href="https://fonts.gstatic.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css?family=Bitter:400,400i,700&display=swap" rel="stylesheet">

  

</head>


  <body>

    <header class="site-header">

  <div class="wrapper">

    <a class="site-title" href="/">Jimmy Farillo</a>

    <nav class="site-nav">
      
        
        <a class="page-link" href="/about/">About</a>
      
        
        <a class="page-link" href="/archives/">Archives</a>
      
        
        <a class="page-link" href="https://github.com/yous/whiteglass">GitHub</a>
      
    </nav>

  </div>

</header>


    <main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    
      <h1 class="post-title" itemprop="name headline">Async/Await in ES7 (ES2016)</h1>
    
    <p class="post-meta"><time datetime="2015-08-27T00:00:00-04:00" itemprop="datePublished">Aug 27, 2015</time></p>
  </header>

  <div class="post-content" itemprop="articleBody">
    <p>I’ve recently been
<a href="/2015/08/13/everything-you-want-to-know-about-koa/">learning a bit about Koa</a>
, which uses ES6 (ES2015) generator functions in its design and allows us to
treat our asynchronous operations differently than using callbacks or promises.</p>

<p>After <a href="http://www.nycnode.com/videos/jimmy-farrell-downstream-and-upstream-request-flow-with-the-koa-web-framework">I presented about Koa at the NYC Node.js
meetup</a>,
fellow presenter <a href="https://twitter.com/eddiezane">Eddie Zaneski</a> showed me
something even more awesome than generators: <code class="language-plaintext highlighter-rouge">async</code> / <code class="language-plaintext highlighter-rouge">await</code>.</p>

<p>Here’s an example of <code class="language-plaintext highlighter-rouge">async</code> / <code class="language-plaintext highlighter-rouge">await</code> in action:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>async function doSomeStuff() {
  try {
    let results1 = await returnsAPromise();
    let results2 = await alsoReturnsAPromise();
    return { results1, results2 };
  } catch (err) {
    throw new Error(err);
  }
}
</code></pre></div></div>

<p>Our function is defined as an <code class="language-plaintext highlighter-rouge">async function</code>, which gives us access to a new
keyword, <code class="language-plaintext highlighter-rouge">await</code>. This keyword does exactly what it says; it waits for an
asynchronous operation to complete (either resolve or reject) before continuing
on with the rest of the function’s code.</p>

<p>The asynchronous operation that is being waited for must return a promise. If
that promise resolves successfully, then the resolved value is returned from
<code class="language-plaintext highlighter-rouge">await</code>. It the promise is rejected, the execution of the code moves in the
<code class="language-plaintext highlighter-rouge">catch</code> block.</p>

<p>This code structure may look familiar if you read my post on Koa. That’s
because Koa and <code class="language-plaintext highlighter-rouge">async</code> / <code class="language-plaintext highlighter-rouge">await</code> are both built using coroutines. However, the
internals of how each implements coroutines is quite different. In short, Koa
uses generator functions and a library called co, while <code class="language-plaintext highlighter-rouge">async</code> / <code class="language-plaintext highlighter-rouge">await</code> uses
a library called node-fibers. More on this here.</p>

<p>Back to the code.</p>

<p>Dealing with asynchronicity using <code class="language-plaintext highlighter-rouge">async</code> / <code class="language-plaintext highlighter-rouge">await</code> looks a lot like
synchronous code, and that’s the whole point. No need for messy callbacks or
promises to handle control flow.</p>

<p>And though the code may look synchronous, <code class="language-plaintext highlighter-rouge">async</code> / <code class="language-plaintext highlighter-rouge">await</code> does not block the
JavaScript event loop. This means that other operations can be performed while
our function is awaiting the promise to be resolved/rejected.</p>

<p>Concurrency with <code class="language-plaintext highlighter-rouge">async</code> / <code class="language-plaintext highlighter-rouge">await</code> is also quite simple by wrapping the
asynchronous operations that are to be performed in parallel in a
<code class="language-plaintext highlighter-rouge">Promise.all</code>. Like so:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>async function manyThings() {
  try {
    let promises = [thing1(), thing2(), thing3()];
    await Promise.all(promises);
  } catch (err) {
    throw new Error(err);
  }
}
</code></pre></div></div>

<p>I’ve also seen that <code class="language-plaintext highlighter-rouge">await*</code> is proposed syntactic sugar for <code class="language-plaintext highlighter-rouge">Promise.all</code>.
Meaning that we could achieve the same thing as above by doing:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>async function manyThings() {
  try {
    let promises = [thing1(), thing2(), thing3()];
    await* promises;
  } catch (err) {
    throw new Error(err);
  }
}
</code></pre></div></div>

<p>This code is slightly nicer, since we don’t have to directly interact with the
Promise API. But, alas, we may or may not get this syntax when the ES7 specs
are finalized. Either way, I’m definitely looking forward to <code class="language-plaintext highlighter-rouge">async</code> / <code class="language-plaintext highlighter-rouge">await</code>!</p>

  </div>

  

</article>

      </div>
    </main>

    <footer class="site-footer">

  <div class="wrapper">

    <p>
      

&copy;  - Powered by <a href="https://jekyllrb.com">Jekyll</a> &amp; <a href="https://github.com/yous/whiteglass">whiteglass</a> - Subscribe via <a href="https://heyjimmy.co/feed.xml">RSS</a>

    </p>

  </div>

</footer>


  </body>

</html>
