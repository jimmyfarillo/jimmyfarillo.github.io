<!DOCTYPE html>
<html lang="en">

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  
  
  <title>The Basics of Database Indexes for Relational Databases</title>
  <meta name="description" content="The purpose of creating an index on a particular table in your database is to make it faster to search through the table and find the row or rows that you want. The downside is that indexes make it slower to add rows or make updates to existing rows for that table. So adding indexes can increase read performance and decrease write performance. Indexes are also used to enforce uniqueness constraints, but I won’t go into that for this post.">
  

  <link rel="stylesheet" href="/assets/main.css">
  <link rel="canonical" href="https://heyjimmy.co/2017/08/23/the-basics-of-database-indexes-for-relational-databases/">
  
  
  <link rel="alternate" type="application/rss+xml" title="Jimmy Farillo" href="https://heyjimmy.co/feed.xml">

  

  
  <meta property="og:title" content="The Basics of Database Indexes for Relational Databases">
  <meta property="og:site_name" content="Jimmy Farillo">
  <meta property="og:url" content="https://heyjimmy.co/2017/08/23/the-basics-of-database-indexes-for-relational-databases/">
  <meta property="og:description" content="The purpose of creating an index on a particular table in your database is to make it faster to search through the table and find the row or rows that you want. The downside is that indexes make it slower to add rows or make updates to existing rows for that table. So adding indexes can increase read performance and decrease write performance. Indexes are also used to enforce uniqueness constraints, but I won’t go into that for this post.">
  
  
  <meta name="twitter:card" content="summary">
  
  <meta name="twitter:title" content="The Basics of Database Indexes for Relational Databases">
  <meta name="twitter:description" content="The purpose of creating an index on a particular table in your database is to make it faster to search through the table and find the row or rows that you want. The downside is that indexes make it...">
  
  

  <link rel="dns-prefetch" href="https://fonts.gstatic.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css?family=Bitter:400,400i,700&display=swap" rel="stylesheet">

  

</head>


  <body>

    <header class="site-header">

  <div class="wrapper">

    <a class="site-title" href="/">Jimmy Farillo</a>

    <nav class="site-nav">
      
        
        <a class="page-link" href="/about/">About</a>
      
        
        <a class="page-link" href="/archives/">Archives</a>
      
        
        <a class="page-link" href="https://github.com/yous/whiteglass">GitHub</a>
      
    </nav>

  </div>

</header>


    <main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    
      <h1 class="post-title" itemprop="name headline">The Basics of Database Indexes for Relational Databases</h1>
    
    <p class="post-meta"><time datetime="2017-08-23T00:00:00-04:00" itemprop="datePublished">Aug 23, 2017</time></p>
  </header>

  <div class="post-content" itemprop="articleBody">
    <p>The purpose of creating an index on a particular table in your database is to
make it faster to search through the table and find the row or rows that you
want. The downside is that indexes make it slower to add rows or make updates to
existing rows for that table. So adding indexes can increase read performance
and decrease write performance. Indexes are also used to enforce uniqueness
constraints, but I won’t go into that for this post.</p>

<h2 id="but-first-lets-talk-about-karaoke">But First, Let’s Talk About Karaoke!</h2>

<p>Besides being my favorite pastime (just FYI, I’m Filipino), karaoke provides a
good analogy for indexes and might help you when reading the rest of this post.</p>

<p>All karaoke joints I’ve been to provide songbooks that contain the list of songs
you can sing. The pages are organized like a database table, usually with 3
columns: song title, artist, and code. The code is what you enter into the
system to bring up the karaoke track. And there are usually two songbooks: one
sorted by artist name and one sorted by song title. That way you can either
think of an artist you want to sing and then look through their songs, or look
up a specific song title you know you want to sing or in case you don’t know the
artist’s name. These songbooks are like indexes for the database of songs. They
provide a sorted list of data that is easily searchable by relevant information.
There isn’t an index for the code column because that information is not
relevant information that you would search by.</p>

<p>Back to actual databases…</p>

<h2 id="how-do-indexes-increase-read-performance">How Do Indexes Increase Read Performance?</h2>

<p>Think about the primary key column of a particular table. It is usually the <code class="language-plaintext highlighter-rouge">id</code>
column, and it is usually a digit that increments with each new row in the
table. So when you try to retrieve a specific row from the database using its
<code class="language-plaintext highlighter-rouge">id</code>, the database doesn’t need to search through every single row to find the
one you’re asking for; the data is already sorted and can be searched using
efficient algorithms. Even if you were to rearrange the rows in the table so
that the <code class="language-plaintext highlighter-rouge">id</code> column was unsorted, the primary key column of tables is
automatically indexed, meaning there is a copy of that column with the sorted
data that the database will use to search. And that index contains pointers to
the actual rows in the table, so once it has found the correct <code class="language-plaintext highlighter-rouge">id</code> from that
copied data, it knows exactly where to find the rest of the information for that
row.</p>

<p>Indexes on columns that are not the primary key column work in the same way. For
example, you might have an articles table in your database that contains columns
for <code class="language-plaintext highlighter-rouge">title</code>, <code class="language-plaintext highlighter-rouge">body</code>, and <code class="language-plaintext highlighter-rouge">published_at</code>, as well as the primary key <code class="language-plaintext highlighter-rouge">id</code>.
Depending on how you query for data in your application, you might want to add
indexes on some of these columns to improve read performance.</p>

<p>If your application has a feature where you can search for articles by their
title, it might be wise to put an index on the <code class="language-plaintext highlighter-rouge">title</code> column. This will create
a copy of that column where all the articles’ titles are sorted. Maybe your
application also allows users to view articles from a specific time period that
they define. Instead of the database having to check every single row’s
<code class="language-plaintext highlighter-rouge">published_at</code> column, you can put an index on that column, and the database
will be able to easily find the articles that were published in that time frame
because they will all be right next to each other. However, it seems unnecessary
(and a bit ridiculous) to put on index on the <code class="language-plaintext highlighter-rouge">body</code> column because your
application is unlikely to query the <code class="language-plaintext highlighter-rouge">articles</code> table by the full contents of
each article. (There are much better ways to search through large bodies of text
in databases.)</p>

<p>Indexes can also be useful for foreign key columns when dealing with
associations. Let’s say the articles table also contains an <code class="language-plaintext highlighter-rouge">author_id</code> column
that corresponds to the <code class="language-plaintext highlighter-rouge">id</code> column on the users table. If you put an index on
the <code class="language-plaintext highlighter-rouge">author_id</code> column, when you query the database for all the articles by a
particular author, the results can be found much faster because all articles by
that author will be grouped together.</p>

<h2 id="indexes-on-multiple-columns">Indexes On Multiple Columns</h2>

<p>You can also create a single index from multiple columns in a table. Extending
the example from above, maybe your application allows authors to view their own
articles, and the default view is to show them in reverse chronological order.
On your <code class="language-plaintext highlighter-rouge">articles</code> table, it would make sense to create an index using both the
<code class="language-plaintext highlighter-rouge">author_id</code> and <code class="language-plaintext highlighter-rouge">published_at</code> columns. Here’s a diagram of how you might think
about that index:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>| author_id | published_at |
|-----------|--------------|
|           | 2017-08-17   |
|     1     | 2017-08-20   |
|           | 2017-08-22   |
|-----------|--------------|
|           | 2017-08-14   |
|           | 2017-08-20   |
|     2     | 2017-08-21   |
|           | 2017-08-22   |
|           | 2017-08-23   |
|-----------|--------------|
|     3     | 2017-08-01   |
</code></pre></div></div>

<p>Now when querying the database for all the articles by an author and ordered by
their <code class="language-plaintext highlighter-rouge">published_at</code> dates, the database can use this index to quickly retrieve
the data.</p>

<p>When creating an index from multiple columns, it is important that you specify
the correct order of the columns. The above index was created by first
specifying the <code class="language-plaintext highlighter-rouge">author_id</code> column and then the <code class="language-plaintext highlighter-rouge">published_at</code> column. Had it
been reversed, the index would not be nearly as useful for the page we want:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>| published_at | author_id |
|--------------|-----------|
| 2017-08-01   | 3         |
|--------------|-----------|
| 2017-08-07   | 3         |
|--------------|-----------|
| 2017-08-14   | 2         |
|              | 3         |
|--------------|-----------|
| 2017-08-17   | 1         |
|--------------|-----------|
| 2017-08-20   | 1         |
|              | 2         |
|--------------|-----------|
| 2017-08-21   | 2         |
|--------------|-----------|
| 2017-08-22   | 1         |
|              | 2         |
|--------------|-----------|
| 2017-08-23   | 2         |
</code></pre></div></div>

<p>When creating an index, you want the database to be able to eliminate as many
items as possible for at each step of its search. In the first example, after
finding the appropriate <code class="language-plaintext highlighter-rouge">author_id</code>, all other rows for other authors are
eliminated, and the database then just has to search through a handful of
remaining rows. The second index is not even usable for our purposes of showing
a single author’s articles in reverse chronology because there is no way to
effectively search through the indexed data. So keep in mind the column order
that will create the index that will be most beneficial to your database
queries.</p>

<h2 id="how-do-indexes-decrease-write-performance">How Do Indexes Decrease Write Performance?</h2>

<p>The cost of improving database read times using indexes is that write times
suffer. Adding a new row to a table without indexes is simple. The database
finds the next available space in the table to add the new entry and adds it,
that’s it. However, when adding a new row to a table with one or more indexes,
the database adds the new entry to the table, and then it has to add a new entry
into each index on that table, making sure to insert the entry into the correct
spot in the index to ensure that the data is properly sorted. And this
performance degradation applies to creates, updates, and deletes for the table.
For this reason, adding unnecessary indexes on tables should be avoided, and
indexes that are no longer used should be removed.</p>

<p>Adding indexes is about improving performance of search queries. Maybe the goal
of your database is to provide a data store that is often written to and rarely
read from. If that is the case, decreasing the performance of the more common
operation, writing, is probably not worth the increase in performance you get
from reading.</p>

  </div>

  

</article>

      </div>
    </main>

    <footer class="site-footer">

  <div class="wrapper">

    <p>
      

&copy;  - Powered by <a href="https://jekyllrb.com">Jekyll</a> &amp; <a href="https://github.com/yous/whiteglass">whiteglass</a> - Subscribe via <a href="https://heyjimmy.co/feed.xml">RSS</a>

    </p>

  </div>

</footer>


  </body>

</html>
